# 카프카의 내부 동작 원리와 구현
## 카프카 리플리케이션
### 리플리케이션 동작 개요

replication-factor 옵션으로 관리자기 지정한 수만큼의 리플리케이션을 가질수 있기때문에 브로커 장애가 발생해도 메시지 손실 없이 안정적으로 메시지를 주고받을 수 있다.

### 리더와 팔로워

모두 동일한 리플리케이션이라 하더라도 리더만의 역할이 따로 있기 때문에 특별히 카프카에선 리더를 특별히 강조해 표시한다.

리더는 리플리케이션 중 하나가 선정되며 모든 읽기와 쓰기는 그 리더를 통해서만 가능합니다. 다시 말해 프로듀서는 모든 리플리케이션에 메시지를 보내는 것이 아니라 리더에게만 메시지를 전송한다.

리더는 읽고 쓰는 동작은 물론 팔로워가 리플리케이션 동작을 잘 수행하고 있는지도 판단함.

모든 팔로워의 복제가 완료되면 리더는 내부적으로 커밋되었다는 표시를 하게된다. 마지막 커밋 오프셋 위치는 하이퍼워터마크라고 부른다.
컨슈머는 커밋된 메시지만 읽을수 있다.

replication-offset-checkpoint 라는 파일의 내용을 확인하고 리플리케이션되고 있는 다른 브로커들과 비교해서 살펴보면 어떤 브로커, 토픽, 파티션에 문제가 있는지 파악할수 있다.

### 리플리케이션 동작

팔로워가 메시지를 정상적으로 처리했는지에 대한 ACK를 받는 부분을 제거 하면서 성능을 향상시켰다.

팔로워의 메시지 동기화 요청을(offset) 을 확인해서 해당 메시지가 모두 동기화 되었는지 확인한다.

리플리케이션동작도 리더가 푸쉬하는 방식이 아닌 팔로워가 풀하는 방식으로 동작하는데 이는 리더의 부하를 줄여주기 위해서이다.

### 리더에포크(leader epoch)

팔로워는 장애 복구시에 리더에게 리더에포크를 요청해서 하이워터마크를 조정한다.

### 컨트롤러 

리더 선출을 맡고 있다.

### 로그(로그 세그먼트)

카프카의 토픽으로 들어오는 메시지는 세그먼트라는 파일에 저장된다.

컴팩션은 카프카에서 제공하는 로그 세그먼트 관리 정책 중 하나로 로그를 삭제하지 않고 컴팩션하여 보관할수 있다.