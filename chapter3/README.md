# 카프카 기본 개념과 구조
## 카프카 기초

### 리플리케이션

`replication.factor` : 1,2,3(all)

토픽이 리플리케이션 되는게 아니라 토픽 파티션이 리플리케이션됨

리플리케이션 팩테에 따라서 리소스가 소모되는 기준이 틀리다.

* 테스트 환경 : 리플리케이션 팩터 1
* 운영 환경(약깐의 유실을 허용함) : 2
* 운영 환경(유실을 미허용) : 3


### 파티션

하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 
토픽 하나를 여러 개로 나눠 병렬 처리가 가능하게 만드는 것을 파티션이라고 한다.

파티션 수만큼 컨슈머를 연결할 수 있다.

* [Apache Kafka 및 Confluent 플랫폼용 크기 계산기](https://eventsizer.io/)

컨슈머의 LAG 이란 : 프로듀서가 보낸 메시지 수 - 컨슈머가 가져간 메시지수 를 나타 낸다.(처리 하지 못한 메시지수)

### 세그먼트

세그먼트 : 토픽에 메시지가 저장될때 세그먼트라고 하는 로그 파일 형태로 저장됨

## 카프카 핵심 개념

### 분산시스템

* 높은 성능
* 장애대응에 탁월(분산저장, 리플리케이션)
* 시스템 확장에 용의(브로커 추가)

### 페이지 캐시

페이지 캐시는 직접 디스크에 읽고 쓰는 대신 물리메모리중 애플리케이션이 사용하지 않는 일부 잔여 메모리를 활용
(디스크 IO를 줄여서 성능을 향상시킴)

### 배치 전송처리

프로듀서와 컨슈머들은 배치 처리가 가능하다. 메시지 전송에 드는 네트워크 오버헤드를 줄일수 있다.

### 압축 전송
메시지 압축을 통해서 네트워크 대역폭이나 회선 비용을 줄일수 있다. 배치전송과 결합해서 사용하면 시너지를 낼수 있다.

### 토픽, 파티션, 오프셋

토픽 -> 파티션

파티션에 메시지가 저장되는 위치를 offset 이라고 부름


### 고가용성 보장

분산 시스템이라서 고가용성을 보장한다.

카프카에선 원본과 리플리케이션을 구분하기 위해 리더와 팔로워라고 부른다.

| 리플리케이션 팩터 수 | 리더 수 | 팔로워 수 |
|-------------|------|-------|
| 2           | 1    | 1     |
| 3           | 1    | 2     |
| 4           | 1    | 3     |

### 주키퍼의 의존성

분산 애플리케이션의 코디네이터 역활

카프카의 메타데이터를 저장하고 각 브로커를 관리하는 중요한 역활

## 카프카 기본 동작

### 프로듀서 디자인

ProducerRecord는 토픽, 파티션키, 벨류로 구성된다. 토픽과 벨류는 필수값 파티션키는 옵션값이다.

send() -> 시리얼라이저 -> 파티셔너

파티션을 지정하지 않으면 기본적으로 라운드로빈 방식으로 동작한다.

전송이 실패하면 재시도 동작이 이뤄지고 지정된 횟수만큼의 재시도가 실패하면 최종 실패를 전달한다.

### 프로듀서 주요 옵션
| 프로듀서 옵션                           | 설명                                                                                                                 | 
|-----------------------------------|--------------------------------------------------------------------------------------------------------------------|
| bootstrap.servers                 | 카프카 클러스터에 연결하기위한 호스트와 포트정보                                                                                         | 
 | client.dns.lookup                 | 하나의 호스트에 여러 IP를 맵핑해 사용하는 일분 환경에서 클라이언트가 하나의 IP를 연결하지 못할경우에 다른 IP를 시도하는 설정                                          |
| acks                              | 메시지 전송후에 요청을 완료하기를 결정하는 옵션 0, 1, all(-1) 0은 리더가 메시지를 받았는지 확인 하지 않음, 1은 리더가 메시지를 받았는지 확인, all은 팔로워가 메시지를 받았는지 까지 확인 |
| buffer.memory                     | 프로듀서가 카프카 서버로 데이터를 보내기 위해 잠시 대기 할수 있는 전체 메모리 바이트                                                                   |
| compression.type                  | 프로듀서가 메시지 전송시 선택할수 있는 압축 타입                                                                                        |
| enable.idempotence                | 설정을 true로 하는 경우 중복업는 전송이 가능하며 이와 동시에 in.flight.requests.per.connection은 5 이하, retries는 0 이상, acks는 all로 설정해야됨      |
| in.flight.requests.per.connection | 하나의 커텍션에서 프로듀서가 최대한 ack없이 전송할수 있는 요청수 메시지 순서가 중요하면 1로 설정할것을 권장하지만 성능이 떨어짐                                          |
| retries                           | 일시적인 오류로 인해 전송에 실패한 데이터를 다시 보내는 횟수                                                                                 |
| batch.size                        | 프로듀서는 동일한 파티션으로 보내는 여러데이터를 함께 배치로 보내려고 시도 한다.                                                                      |
| linger.ms                         | 배치 형태의 메시지를 보내지 전에 추가적인 메시지를 위해 기다르는 시간(제한시간)                                                                      |
| transactional.id                  | 정확히 한 번 전송을 위해 사용하는 옵션, 동일한 transactionalId에 한해 정확히 한번 전송을 보장한다.                                                   |

### 컨슈머 기본동작
컨슈머수 와 파티션 수가 1:1로 매칭되는것이 이상적임

파티션 수보다 컨슈머 수가 더 많으면 처리량이 높아지는것이 아니라 그냥 대기상태로만 존재한다.

### 컨슈머 주요 옵션
| 프로듀서 옵션                       | 설명                                                                         |
|-------------------------------|----------------------------------------------------------------------------|
| bootstrap.servers             | 카프카 클러스터에 연결하기위한 호스트와 포트정보                                                 | 
| fetch.min.bytes               | 한번에 가져올 수 있는 최소 데이터 크기                                                     |
| group.id                      | 컨슈머가 속한 컨슈머 그룹을 식별하는 식별자                                                   |
| heartbeat.interval.ms         | 일반적으로 session.timeout.ms의 1/3로 설정함                                         |
| max.partition.fetch.bytes     | 파티션당 가지고 올수 있는 최대 크기                                                       |
| session.timeout.m             | 이 시간을 이용해 컨슈머가 종료된 것인지를 판단한다. 많약 이시간까지 하트비트를 보내지 않으면 종료된것으로 판단해서 리벨런싱을 시작함 |
| enable.auto.commit            | 백그라운드에서 주기적으로 오프셋을 커밋한다.                                                   |
| auto.offset.reset             | 오프셋이 없을때 동작방식 결정                                                           |
| fetch.max.byte                | 한 번의 가져오기를 요청으로 가져올 수 있는 최대 크기                                             |
| group.instance.id             | 컨슈머의 고유한 식별자                                                               |
| isolation.level               | 트랜젝션 컨슈머에서 사용되는 옵션                                                         |
| max.poll.records              | 한번에 poll() 요청으로 가지고 오는 최대 메시지 수                                            |
| partition.assignment.strategy | 파티션 할당 전략이며 기본값은 range                                                     |
| fetch.max.wait.ms             | fetch.min.byte 설정된 데이터 보다 적을때 최대한 대기하는 시간                                  |

### 컨슈머 그룹의 이해

컨슈머는 컨슈머 그룹안에 속한 구조로 하나의 컨슈머 그룹에 여러대 컨슈머가 구성될수 있다.