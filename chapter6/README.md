# 컨슈머의 내부 동작 원리와 구현
## 컨슈머 오프셋 관리

컨슈머의 가장 핵심은 오프셋 관리 이다.
컨슈머는 카프카에 저장된 메시지를 꺼내오는 역할을 하기 때문에 컨슈머가 메시지를 어디까지 가져왔는지를 표시하는 것은 중요하다.

카프카에서는 메시지의 워치를 나타내는 위치를 오프셋이라고 부르는데 이 오프셋은 숫자 형태로 나타낸다.
컨슈머 그룹은 자신의 오프셋 정보를 카프카에서 토픽에 저장한다.(_consumer_offsets 토픽)

_consumer_offsets 토픽 설정 정보(설정 정보는 바꿀수 있다.)
* offsets.topic.num.partition : 기본값 50
* offsets.topic.replication.factor: 기본값 3

## 그룹 코디네이터

컨슈머는 하나의 컨슈머 그룹의 구성원으로 속하며, 컨슈머 그룹 내의 각 컨슈머들은 서로 자신의 정보를 공유하면서 하나의 공동체로 동작한다.
컨슈머 그룹에서 각 컨슈머들에게 작업을 균등하게 분해하는 동작을 컨슈머 리밸런싱이라고 부르거나 컨슈머 리밸런싱이 일어났다라고 표현한다.

컨슈머 그룹을 관리하기 위해 별도의 코디네이터가 존재하는데 그룹 코디네이터라고 부른다.

컨슈머 들이 그룹 코디네이터에 join 또는 leave 요청을 보냄으로서 자연스럽게 처리 된다.

leave 요청을 보내지 못하는 비정상적인 종료되는 경우는 컨슈머와 컨슈머 그룹이 서로 하트비트를 주고 받는데 이렇게 하트비트를 주기적으로 주고 받으면서 컨슈머가 살아 있는지 확인을 합니다.

| 컨슈머 옵션                | 값      | 설명                                                                                  |
|-----------------------|--------|-------------------------------------------------------------------------------------|
| heartbeat.interval.ms | 3000   | 기본값은 3000, 그룹 코디네이터 컨슈머간에 하트비트 인터벌 시간 , session.timeout.ms 보다 낮게 설정하고 1/3 수준이 적정하다. |
| session.timeout.ms    | 10000  | 기본값은 10000, 특정시간 내에 하트비트를 받지 못하면 컨슈머 그룹에서 제거되는 시간                                   | 
| max.poll.interval.ms  | 300000 | 기본값은 3000000, 컨슈머의 poll 호출이 없을때 컨슈머 그룹에서 제거되는 시간                                    |

리벨런싱 동작의 경우에 따라 매우 높은 비용이 지출되므로 가급적 리밸런싱이 자주 발생하지 않도록 해야 된다.

## 스테틱 멤버십

불필요한 리밸런싱을 방어하기 위해 카프카 2.3 부터 스테틱 멤버십이라는 개념을 도입했다.

스테틱 멤버십이란 컨슈머 그룹 내에서 컨슈머가 재시작등으로 그룹에서 나갔다가 다시 합류하더라도 리밸런싱이 일어나지 않게 합니다.
컨슈머마다 인식할수 있는 ID를 부여하고 딧; 힙류하더라도 그룹 코디네이터가 기존 구성원임을 인식할수 있게 하는것이다.

설정은 group.instance.id 옵셥에 컨슈머 인스턴스 별로 고유한 값을 입력해야 된다.
만약 스테틱 맴버십을 적용하면 session.timeout.ms를 기본값 보다 큰값으로 조정해야 된다.

만약 컨슈머 재시작 시간이 2분이면 2분보다 큰값을 설정하는것이 좋다.

## 컨슈머 파티션 할당 전략

컨슈머 옵션 partition.assignment.strategy 를 사용해서 설정함

| 파티션 할당 전략                                 | 설명                                                                 |
|-------------------------------------------|--------------------------------------------------------------------|
| RangeAssignor(레인지 파티션 할당)                 | 파티션 할당 전략의 기본값으로 토픽별로 할당 전략을 사용함. 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 유용함 |
| RoundRobinAssignor(라운드 로빈 파티션 할당)         | 사용가능한 파티션과 컨슈머들을 라운드 로빈으로 할당함. 균등한 분배 가능                           |
| StickyAssignor(스티키 파티션 할당)                | 컨슈머가 컨슘하고 있는 파티션을 계속 유지 할 수 있음                                     |
| CooperativeStickyAssignor(협력적 스티키 파티션 할당) | 스티키 방식과 유사하지만, 전체 일시 정지가 아닌 연속적인 재조정 방식                            |

### 레인지 파티션 할당 전략

파티션 할당 전략중 기본전략

토픽에 파티션을 순서대로 나열한후 컨슈머를 순서대로 정렬합니다. 
그리고 전체 파티션 / 컨슈머 수를 해서 파티션을 할당하고 나머지가 남으면 앞에 컨슈머 순서대로 추가 파티션을 할당 한다.

동일한 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션수를 가진 2개이상의 토픽을 컨슘할때 유용하다.

### 라운드 로빈 파티션 할당 전략
파티션 할당 방식중 가장 간단한 할당 방식

컨슈머 파티션과 컨슈머 그룹 내의 모든 컨슈머를 나열한 후 라운드 로빈으로 하나씩 파티션과 컨슈머에 할당하는 전략

### 스티키 파티션 할당 전략
재할당 작업이 발생해도 기존에 매핑했던 파티션과 컨슈머를 최대한 유지하려고 하는 전략

목적
* 가능한 균형 잡힌 파티션 할당
* 재할당이 되어도 기존의 할당된 파티션 정보를 보장하는것

스티키 전략이라도 무조건 기존에 맴핑했던 파티션과 컨슈머가 무조건 유지되지는 않는다.

스티키 전략의 규칙
* 컨슈머들의 최대 할당된 파티션의 수의 차이는 1
* 기존에 존재하는 파티션 할당은 최대한 유지함
* 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거함
* 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에 할당

### 협력적 스티키 파티션 할당 전략
결과적으로는 스티키 전략이랑 같지만 컨슈머 그룹 내부의 리밸런싱 동작이 한층 더 고도화됨

EAGER 프로토콜은 컨슈머 리밸런싱 동작 시 컨슈머에 할당된 모든 파티션을 항상 취소함

항상 파티션을 취소하는 이유
* 컨슈머들의 파티션 소유권 변경
* 그룹내의 여러파티션에 대한 소유권 변경작업(새 파티션 할당작업)이 동시에 이뤄져야 하므로 로직을 단순화 하게 구현 하기 위해서

기존 리밸런싱은 한번에 완료 된다는 장점이 있지만 모든 컨슈머의 동작이 멈춘다는 단점이 있다.

새로운 COOPERATIVE 프로토콜은 몇번에 걸쳐서 리밸런싱이 일어난다. 안전하게 파티션 소유권을 이동하기 위해 리밸런싱 작업이 수차례에 걸처 진행하는것도 나쁘지 않다는것에서 출발함

## 정확히 한 번 컨슈머 동작

컨슈머에서 정확히 한번 동작은 ISOLATION_LEVEL_CONFIG 라는 설정만 추가 하면된다. 거기에 read_committed 로 옵션값을 변경하면 트랜젝션 완료된 메시지만 읽을수 있다.

트랜젝션 컨슈머라고 해서 정확히 한번만 가지고 오는것은 아니다.